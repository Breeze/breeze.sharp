using Breeze.Sharp.Core;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Linq;

namespace Breeze.Sharp {

  /// <summary>
  /// Container for all of the metadata about a specific type of Entity.
  /// </summary>
  [DebuggerDisplay("{Name}")]
  public sealed class EntityType : StructuralType, IJsonSerializable {

    internal EntityType(MetadataStore metadataStore) : base(metadataStore) {
      _selfAndSubEntityTypes.Add(this);
    }

    internal void UpdateFromJNode(JNode jNode) {
      var shortName = jNode.Get<String>("shortName");
      var ns = jNode.Get<String>("namespace");
      var name = TypeNameInfo.ToStructuralTypeName(shortName, ns);
      var et = MetadataStore.GetEntityType(name);

      Check(et.BaseEntityTypeName, jNode.Get<String>("baseTypeName"), "BaseEntityType");
      // For now this doesn't need to match 
      et.IsAbstract = jNode.Get<bool>("isAbstract");

      et.AutoGeneratedKeyType = jNode.GetEnum<AutoGeneratedKeyType>("autoGeneratedKeyType");
      var drn = jNode.Get<String>("defaultResourceName");
      if (drn != null) {
        MetadataStore.SetResourceName(drn, et, true);
      }
      jNode.GetJNodeArray("dataProperties").ForEach(jn => {
        var dpName = jn.Get<String>("name");
        var dp = et.GetDataProperty(dpName);
        dp.UpdateFromJNode(jn);
      });
      jNode.GetJNodeArray("navigationProperties").ForEach(jn => {
        var npName = jn.Get<String>("name");
        var np = et.GetNavigationProperty(npName);
        np.UpdateFromJNode(jn);
      });
      et._validators = new ValidatorCollection(jNode.GetJNodeArray("validators"));
      // custom
      
    }

    

    JNode IJsonSerializable.ToJNode(Object config) {
      var jo = new JNode();
      jo.AddPrimitive("shortName", this.ShortName);
      jo.AddPrimitive("namespace", this.Namespace);
      jo.AddPrimitive("baseTypeName", this.BaseEntityTypeName);
      jo.AddPrimitive("isAbstract", this.IsAbstract, false);
      jo.AddPrimitive("autoGeneratedKeyType", this.AutoGeneratedKeyType.ToString());
      jo.AddPrimitive("defaultResourceName", this.DefaultResourceName);
      jo.AddArray("dataProperties", this.DataProperties.Where(dp => dp.IsInherited == false));
      jo.AddArray("navigationProperties", this.NavigationProperties.Where(np => np.IsInherited == false));
      jo.AddArray("validators", this.Validators);
      // jo.AddProperty("custom", this.Custom.ToJObject)
      return jo;
    }

    internal void Check(Object v1, Object v2, String name) {
      if (v1 == null && v2 == null) return;
      if (Object.Equals(v1, v2)) return;
      var msg = String.Format("EntityType) metadata mismatch. EntityType: '{0}'.  Metadata property: '{1}'.  Client value: '{2}',  Server value: '{3}'",
        this.Name, name, (v1 ?? "").ToString(), (v2 ?? "").ToString());
      MetadataStore.AddMessage(msg, MessageType.Error);
    }

    #region Public properties

    /// <summary>
    /// The base EntityType (if any) for this EntityType.
    /// </summary>
    public EntityType BaseEntityType {
      get { return _baseEntityType; }
      internal set {
        if (_baseEntityType == value) return;
        _baseEntityType = value;
        if (_baseEntityType != null) {
          _baseEntityType.AddSubEntityType(this);
        }
      }
    }

    internal String BaseEntityTypeName {
      get { return BaseEntityType == null ? "" : BaseEntityType.Name; }
    }

    /// <summary>
    /// The AutoGeneratedKeyType for this EntityType.
    /// </summary>
    public AutoGeneratedKeyType AutoGeneratedKeyType {
      get { return _autoGeneratedKeyType; }
      set {
        if (_autoGeneratedKeyType == value) return;
        _autoGeneratedKeyType = value;
        bool isAutoIncrementing = ( value == AutoGeneratedKeyType.Identity);
        _keyProperties.ForEach(kp => kp.IsAutoIncrementing = isAutoIncrementing);
      }
    }

    /// <summary>
    /// Always true - property is defined at the StructuralType level.
    /// </summary>
    public override bool IsEntityType { get { return true; } }

    /// <summary>
    /// The default resource name associated with this EntityType. An EntityType may be queried 
    /// via a variety of 'resource names' but this one is used as the default when no resource name 
    /// is provided. This will occur when calling loadNavigationProperty or when executing any 
    /// EntityQuery that was created via an EntityKey.
    /// </summary>
    public String DefaultResourceName {
      get { return MetadataStore.GetDefaultResourceName(this); }
    }

    /// <summary>
    /// All EntityTypes that are subtypes of this EntityType.
    /// </summary>
    public ReadOnlyCollection<EntityType> SelfAndSubEntityTypes {
      get { return _selfAndSubEntityTypes.ReadOnlyValues; }
    }

    /// <summary>
    /// All of the data and navigation properties on this EntityType.
    /// </summary>
    public override IEnumerable<StructuralProperty> Properties {
      get { return _dataProperties.Cast<StructuralProperty>().Concat(_navigationProperties); }
    }

    /// <summary>
    /// The <see cref="NavigationProperty"/>'s associated with this EntityType.
    /// </summary>
    public ICollection<NavigationProperty> NavigationProperties {
      get { return _navigationProperties.ReadOnlyValues; }
    }

    /// <summary>
    /// The DataProperties associated with this EntityType that make up it's EntityKey.
    /// </summary>
    public ReadOnlyCollection<DataProperty> KeyProperties {
      get { return _keyProperties.ReadOnlyValues; }
    }

    /// <summary>
    /// The DataProperties associated with this EntityType that are foreign key properties.
    /// </summary>
    public ReadOnlyCollection<DataProperty> ForeignKeyProperties {
      get { return _foreignKeyProperties.ReadOnlyValues; }
    }

    /// <summary>
    /// The DataProperties on other EntityTypes that are foriegn key properties associated with this EntityType. 
    /// </summary>
    public ReadOnlyCollection<DataProperty> InverseForeignKeyProperties {
      get { return _inverseForeignKeyProperties.ReadOnlyValues; }
    }

    /// <summary>
    /// The DataProperties associated with this EntityType that are concurrency properties.
    /// </summary>
    public ReadOnlyCollection<DataProperty> ConcurrencyProperties {
      get { return _concurrencyProperties.ReadOnlyValues; }
    }

  

    #endregion

    #region Public methods

    /// <summary>
    /// Creates an entity with this EntityType.
    /// </summary>
    /// <returns></returns>
    public IEntity CreateEntity() {
      var entity = (IEntity)Activator.CreateInstance(this.ClrType);
      entity.EntityAspect.EntityType = this;
      return entity;
    }

    /// <summary>
    /// Returns either the DataProperty or the NavigationProperty with the specified name. 
    /// Returns null if none is found.
    /// </summary>
    /// <param name="propertyName"></param>
    /// <returns></returns>
    public override StructuralProperty GetProperty(String propertyName) {
      var dp = GetDataProperty(propertyName);
      if (dp != null) return dp;
      var np = GetNavigationProperty(propertyName);
      if (np != null) return np;
      return null;
    }

    /// <summary>
    /// Returns the NavigationProperty with the specified name. 
    /// Returns null if none is found.
    /// </summary>
    /// <param name="npName"></param>
    /// <returns></returns>
    public NavigationProperty GetNavigationProperty(String npName) {
      return _navigationProperties[npName];
    }

    /// <summary>
    /// Returns the 'Name' of this EntityType.
    /// </summary>
    /// <returns></returns>
    public override string ToString() {
      return this.Name;
    }

    #endregion

    #region protected/internal

    private void AddSubEntityType(EntityType entityType) {
      _selfAndSubEntityTypes.Add(entityType);
      if (this.BaseEntityType != null) {
        this.BaseEntityType.AddSubEntityType(entityType);
      }
    }

    internal override DataProperty AddDataProperty(DataProperty dp) {
      var altDp = GetDataProperty(dp.Name);
      if (altDp != null) {
        // this can happen if subtype overrides base type property.
        return altDp;
      }
      base.AddDataProperty(dp);
      if (dp.IsPartOfKey) _keyProperties.Add(dp);
      if (dp.IsConcurrencyProperty) _concurrencyProperties.Add(dp);
      if (dp.IsComplexProperty) _complexProperties.Add(dp);
      if (dp.IsForeignKey) _foreignKeyProperties.Add(dp);
      if (dp.IsAutoIncrementing) this.AutoGeneratedKeyType = AutoGeneratedKeyType.Identity;
      return dp;
    }

    internal NavigationProperty AddNavigationProperty(NavigationProperty np) {
      np.ParentType = this;
      _navigationProperties.Add(np);
      np.UpdateClientServerNames();
      return np;
    }


    internal void UpdateNavigationProperties() {
      NavigationProperties.ForEach(np => UpdateNavigationProperty(np));
    }

    internal void UpdateAutoGeneratedKeyType(bool isAutoIncrementing) {
      this.AutoGeneratedKeyType = isAutoIncrementing ? AutoGeneratedKeyType.Identity : AutoGeneratedKeyType.None;
    }

    internal void UpdateKeyProperties(DataProperty dp) {
      UpdateCollection(_keyProperties, dp, dp.IsPartOfKey);
    }

    internal void UpdateConcurrencyProperties(DataProperty dp) {
      UpdateCollection( _concurrencyProperties, dp, dp.ConcurrencyMode == ConcurrencyMode.Fixed);      
    }

    internal void UpdateForeignKeyProperties(DataProperty dp) {
      UpdateCollection( _foreignKeyProperties, dp, dp.IsForeignKey);
    }

    // not the same as the others above.
    internal void UpdateInverseForeignKeyProperties(DataProperty dp) {
      UpdateCollection( _inverseForeignKeyProperties, dp, true);
    }

    protected void UpdateCollection(SafeList<DataProperty> list, DataProperty dp, bool add) {

      var isSet = list.Contains(dp);
      if (add) {
        if (!isSet) {
          list.Add(dp);
        }
      } else {
        if (isSet) {
          list.Remove(dp);
        }
      }
    }

    private bool UpdateNavigationProperty(NavigationProperty np) {
      var entityType = np.EntityType;

      var invNp = entityType.NavigationProperties.FirstOrDefault(altNp => {
        // Can't do this because of possibility of comparing a base class np with a subclass altNp.
        //return altNp.associationName === np.associationName
        //    && altNp !== np;
        // So use this instead.
        return altNp.AssociationName == np.AssociationName &&
            (altNp.Name != np.Name || altNp.EntityType.Name != np.EntityType.Name);
      });
      np.Inverse = invNp;
      if (invNp == null) {
        // unidirectional 1-n relationship
        np.InvForeignKeyProperties.ForEach(invFkProp => {

          invFkProp.IsForeignKey = true;
          var invEntityType = (EntityType)np.ParentType;

          invFkProp.InverseNavigationProperty = invEntityType.NavigationProperties.FirstOrDefault(np2 => {
            return np2.InvForeignKeyNames.IndexOf(invFkProp.Name) >= 0 && np2.EntityType == invFkProp.ParentType;
          });


        });
      }

      // sets navigation property: relatedDataProperties and dataProperty: relatedNavigationProperty
      np.ForeignKeyProperties.ForEach(dp => dp.RelatedNavigationProperty = np);
      
      return true;
    }

    #endregion

    #region private

    private AutoGeneratedKeyType _autoGeneratedKeyType = AutoGeneratedKeyType.None;
    private readonly NavigationPropertyCollection _navigationProperties = new NavigationPropertyCollection();
    private readonly SafeList<DataProperty> _keyProperties = new SafeList<DataProperty>();
    private readonly SafeList<DataProperty> _foreignKeyProperties = new SafeList<DataProperty>();
    private readonly SafeList<DataProperty> _inverseForeignKeyProperties = new SafeList<DataProperty>();
    private readonly SafeList<DataProperty> _concurrencyProperties = new SafeList<DataProperty>();

    private EntityType _baseEntityType = null;
    private readonly SafeList<EntityType> _selfAndSubEntityTypes = new SafeList<EntityType>();

    #endregion

  }

  /// <summary>
  /// Unique collection of <see cref="EntityType"/>s.
  /// </summary>
  internal class EntityTypeCollection : MapCollection<String, EntityType> {
    protected override String GetKeyForItem(EntityType item) {
      return item.ShortName + ":#" + item.Namespace;
    }
  }

  /// <summary>
  /// AutoGeneratedKeyType is an enum containing all of the valid states for an automatically generated key.
  /// </summary>
  public enum AutoGeneratedKeyType {
    None = 0,
    Identity = 1,
    KeyGenerator = 2
  }




}
