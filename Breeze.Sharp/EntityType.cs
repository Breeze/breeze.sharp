using Breeze.Sharp.Core;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Linq;

namespace Breeze.Sharp {

  /// <summary>
  /// 
  /// </summary>
  [DebuggerDisplay("{Name}")]
  public class EntityType : StructuralType, IJsonSerializable {

    internal EntityType() {
    }

    public void UpdateFromJNode(JNode jNode) {
      var shortName = jNode.Get<String>("shortName");
      var ns = jNode.Get<String>("namespace");
      var name = TypeNameInfo.QualifyTypeName(shortName, ns);
      var et = MetadataStore.Instance.GetEntityType(name);

      Check(et.BaseEntityTypeName, jNode.Get<String>("baseTypeName"), "BaseEntityType");
      // For now this doesn't need to match 
      et.IsAbstract = jNode.Get<bool>("isAbstract");

      et.AutoGeneratedKeyType = jNode.GetEnum<AutoGeneratedKeyType>("autoGeneratedKeyType");
      var drn = jNode.Get<String>("defaultResourceName");
      if (drn != null) {
        MetadataStore.Instance.AddResourceName(drn, et, true);
      }
      jNode.GetJNodeArray("dataProperties").ForEach(jn => {
        var dpName = jn.Get<String>("name");
        var dp = et.GetDataProperty(dpName);
        dp.UpdateFromJNode(jn);
      });
      jNode.GetJNodeArray("navigationProperties").ForEach(jn => {
        var npName = jn.Get<String>("name");
        var np = et.GetNavigationProperty(npName);
        np.UpdateFromJNode(jn);
      });
      et._validators = new ValidatorCollection(jNode.GetJNodeArray("validators"));
      // custom
      
    }

    

    JNode IJsonSerializable.ToJNode(Object config) {
      var jo = new JNode();
      jo.AddPrimitive("shortName", this.ShortName);
      jo.AddPrimitive("namespace", this.Namespace);
      jo.AddPrimitive("baseTypeName", this.BaseEntityTypeName);
      jo.AddPrimitive("isAbstract", this.IsAbstract, false);
      jo.AddPrimitive("autoGeneratedKeyType", this.AutoGeneratedKeyType.ToString());
      jo.AddPrimitive("defaultResourceName", this.DefaultResourceName);
      jo.AddArray("dataProperties", this.DataProperties.Where(dp => dp.IsInherited == false));
      jo.AddArray("navigationProperties", this.NavigationProperties.Where(np => np.IsInherited == false));
      jo.AddArray("validators", this.Validators);
      // jo.AddProperty("custom", this.Custom.ToJObject)
      return jo;
    }



    internal void Check(Object v1, Object v2, String name) {
      if (v1 == null && v2 == null) return;
      if (Object.Equals(v1, v2)) return;
      throw new Exception("EntityType metadata mismatch. EntityType: " + this.Name + ".  Metadata property: " + name);
    }

    #region Public properties

    public EntityType BaseEntityType {
      get { return _baseEntityType; }
      internal set {
        if (_baseEntityType == value) return;
        _baseEntityType = value;
        if (_baseEntityType != null) {
          _baseEntityType.AddSubEntityType(this);
        }
      }
    }

    internal String BaseEntityTypeName {
      get { return BaseEntityType == null ? "" : BaseEntityType.Name; }
    }


    public AutoGeneratedKeyType AutoGeneratedKeyType {
      get { return _autoGeneratedKeyType; }
      set {
        if (_autoGeneratedKeyType == value) return;
        _autoGeneratedKeyType = value;
        bool isAutoIncrementing = ( value == AutoGeneratedKeyType.Identity);
        _keyProperties.ForEach(kp => kp.IsAutoIncrementing = isAutoIncrementing);
      }
    }

    public override bool IsEntityType { get { return true; } }


    public String DefaultResourceName {
      get { return MetadataStore.Instance.GetDefaultResourceName(this); }
    }

    public ReadOnlyCollection<EntityType> Subtypes {
      get { return _subtypes.ReadOnlyValues; }
    }

    public override IEnumerable<StructuralProperty> Properties {
      get { return _dataProperties.Cast<StructuralProperty>().Concat(_navigationProperties); }
    }

    public ICollection<NavigationProperty> NavigationProperties {
      get { return _navigationProperties.ReadOnlyValues; }
    }

    public ReadOnlyCollection<DataProperty> KeyProperties {
      get { return _keyProperties.ReadOnlyValues; }
    }

    public ReadOnlyCollection<DataProperty> ForeignKeyProperties {
      get { return _foreignKeyProperties.ReadOnlyValues; }
    }

    public ReadOnlyCollection<DataProperty> InverseForeignKeyProperties {
      get { return _inverseForeignKeyProperties.ReadOnlyValues; }
    }

    public ReadOnlyCollection<DataProperty> ConcurrencyProperties {
      get { return _concurrencyProperties.ReadOnlyValues; }
    }

  

    #endregion

    #region Public methods

   

    public IEntity CreateEntity() {
      var entity = (IEntity)Activator.CreateInstance(this.ClrType);
      entity.EntityAspect.EntityType = this;
      return entity;
    }

    public override StructuralProperty GetProperty(String propertyName) {
      var dp = GetDataProperty(propertyName);
      if (dp != null) return dp;
      var np = GetNavigationProperty(propertyName);
      if (np != null) return np;
      return null;
    }


    public NavigationProperty GetNavigationProperty(String npName) {
      return _navigationProperties[npName];
    }



    #endregion

    #region protected/internal

    private void AddSubEntityType(EntityType entityType) {
      _subtypes.Add(entityType);
      if (this.BaseEntityType != null) {
        this.BaseEntityType.AddSubEntityType(entityType);
      }
    }

    internal override DataProperty AddDataProperty(DataProperty dp) {
      base.AddDataProperty(dp);
      if (dp.IsPartOfKey) _keyProperties.Add(dp);
      if (dp.IsConcurrencyProperty) _concurrencyProperties.Add(dp);
      if (dp.IsComplexProperty) _complexProperties.Add(dp);
      if (dp.IsForeignKey) _foreignKeyProperties.Add(dp);
      if (dp.IsAutoIncrementing) this.AutoGeneratedKeyType = AutoGeneratedKeyType.Identity;
      return dp;
    }

    internal NavigationProperty AddNavigationProperty(NavigationProperty np) {
      np.ParentType = this;
      _navigationProperties.Add(np);
      return np;
    }


    internal void UpdateNavigationProperties() {
      NavigationProperties.ForEach(np => UpdateNavigationProperty(np));
    }

    internal void UpdateAutoGeneratedKeyType(bool isAutoIncrementing) {
      this.AutoGeneratedKeyType = isAutoIncrementing ? AutoGeneratedKeyType.Identity : AutoGeneratedKeyType.None;
    }

    internal void UpdateKeyProperties(DataProperty dp) {
      UpdateCollection(_keyProperties, dp, dp.IsPartOfKey);
    }

    internal void UpdateConcurrencyProperties(DataProperty dp) {
      UpdateCollection( _concurrencyProperties, dp, dp.ConcurrencyMode == ConcurrencyMode.Fixed);      
    }

    internal void UpdateForeignKeyProperties(DataProperty dp) {
      UpdateCollection( _foreignKeyProperties, dp, dp.IsForeignKey);
    }

    // not the same as the others above.
    internal void UpdateInverseForeignKeyProperties(DataProperty dp) {
      UpdateCollection( _inverseForeignKeyProperties, dp, true);
    }

    protected void UpdateCollection(SafeList<DataProperty> list, DataProperty dp, bool add) {

      var isSet = list.Contains(dp);
      if (add) {
        if (!isSet) {
          list.Add(dp);
        }
      } else {
        if (isSet) {
          list.Remove(dp);
        }
      }
    }

    private bool UpdateNavigationProperty(NavigationProperty np) {
      var entityType = np.EntityType;

      var invNp = entityType.NavigationProperties.FirstOrDefault(altNp => {
        // Can't do this because of possibility of comparing a base class np with a subclass altNp.
        //return altNp.associationName === np.associationName
        //    && altNp !== np;
        // So use this instead.
        return altNp.AssociationName == np.AssociationName &&
            (altNp.Name != np.Name || altNp.EntityType.Name != np.EntityType.Name);
      });
      np.Inverse = invNp;
      if (invNp == null) {
        // unidirectional 1-n relationship
        np.InvForeignKeyProperties.ForEach(invFkProp => {

          invFkProp.IsForeignKey = true;
          var invEntityType = (EntityType)np.ParentType;

          invFkProp.InverseNavigationProperty = invEntityType.NavigationProperties.FirstOrDefault(np2 => {
            return np2.InvForeignKeyNames.IndexOf(invFkProp.Name) >= 0 && np2.EntityType == invFkProp.ParentType;
          });


        });
      }

      // sets navigation property: relatedDataProperties and dataProperty: relatedNavigationProperty
      np.ForeignKeyProperties.ForEach(dp => dp.RelatedNavigationProperty = np);
      
      return true;
    }

    #endregion

    #region private

    private AutoGeneratedKeyType _autoGeneratedKeyType = AutoGeneratedKeyType.None;
    private readonly NavigationPropertyCollection _navigationProperties = new NavigationPropertyCollection();
    private readonly SafeList<DataProperty> _keyProperties = new SafeList<DataProperty>();
    private readonly SafeList<DataProperty> _foreignKeyProperties = new SafeList<DataProperty>();
    private readonly SafeList<DataProperty> _inverseForeignKeyProperties = new SafeList<DataProperty>();
    private readonly SafeList<DataProperty> _concurrencyProperties = new SafeList<DataProperty>();

    private EntityType _baseEntityType = null;
    private readonly SafeList<EntityType> _subtypes = new SafeList<EntityType>();

    #endregion

  }

  public class EntityTypeCollection : MapCollection<String, EntityType> {
    protected override String GetKeyForItem(EntityType item) {
      return item.ShortName + ":#" + item.Namespace;
    }
  }

  public enum AutoGeneratedKeyType {
    None = 0,
    Identity = 1,
    KeyGenerator = 2
  }




}
